<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="author" content="Miguel Vilá" />
        <meta name="viewport" content="width=device-width" />
        <meta http-equiv="Cache-Control" content="max-age=86400, must-revalidate" />
        <title>Miguel Vil&aacute;</title>
        <link rel="stylesheet" type="text/css" title="hakyll_theme" href="../css/haskellmn.css" />
        <link rel="stylesheet" type="text/css" href="../css/markdown.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link href="https://fonts.googleapis.com/css?family=Libre+Baskerville" rel="stylesheet" type="text/css">
    </head>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-74778346-1', 'auto');
        ga('send', 'pageview');

    </script>
    <body>
    <header>
        <h1>Miguel Vil&aacute;</h1>
        <nav>
            <a href="../">Inicio</a>
            <a href="../archive.html">Posts</a>| 
            <a href="https://twitter.com/mglvl/">Twitter</a>
            <a href="https://www.flickr.com/photos/77778296@N07/">Flickr</a>
            <a href="https://github.com/miguel-vila/">Github</a>
            <a href="https://slides.com/miguelvila/">Slides.com</a>
        </nav>
    </header>
    <article>
    <h2>Construyendo un pequeño lenguaje de programación (Parte 0)</h2>
    <div id="content" class="inside">
    <div class="info">
        
        Marzo  9 de 2016
        
    </div>
    <div class="info">
        
        Tags:  
        
    </div>
    <hr>
    <p>Uno de los aparentes ritos de paso en programación funcional es el de construir un pequeño lenguaje de programación. O para ser más preciso construir el intérprete de un lenguaje de programación: algo que recorra un árbol de sintáxis y lo reduzca a un valor. Este ejercicio es bastante común en artículos, libros o cursos.</p>
<p>Por ejemplo el <a href="http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf">artículo</a> de <a href="http://homepages.inf.ed.ac.uk/wadler/">Philip Wadler</a> explicando un patrón común en programación funcional usa un intérprete como motivador.</p>
<p>En el mundo de lenguajes tipo lisp también es muy común, dada la facilidad de recorrer las expresiones. Por ejemplo en el <a href="https://www.coursera.org/course/proglang">curso de lenguajes de programación en coursera</a> hacen el ejercicio de construir un pequeño intérprete usando racket. O tal vez mas conocido es el libro <a href="https://mitpress.mit.edu/sicp/">“Structure and Interpretation of Computer Programs”</a> donde en una buena parte del libro se dedican a hacer lo mismo.</p>
<p>Y mas recientemente la idea de los intérpretes ha sido usada con <a href="https://www.youtube.com/watch?v=hmX2s3pe_qk">propósitos más complejos</a>.</p>
<p>El caso es que la idea de construir algo que ejecute un lenguaje de programación suena bastante ambiciosa y compleja. Pero todos estos ejemplos, traídos del lado de programación funcional, demuestran que, a pequeña escala, la tarea no es tan difícil.</p>
<p>La idea de esta serie de artículos es demostrar eso usando Scala. Y debido a que vamos a usar Scala algunas cosas serán más complicadas. En particular debido a que Scala tiene tipado estático tenemos la tarea de convencer al <em>typechecker</em> que lo que estamos haciendo tiene sentido.</p>
<p>Vamos a crear un lenguaje muy simple. No tendrá funciones, no tendrá declaraciones de tipos y solo habrá dos tipos de datos: números y expresiones booleanas. Tendrá <code>if</code>s y <code>while</code>s y tendrá una sintáxis similar a la de lenguajes tipo C. Por ejemplo para computar los primeros 10 números de fibonacci escribiríamos algo como:</p>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c">a = <span class="dv">0</span>;
b = <span class="dv">1</span>;
i = <span class="dv">1</span>;
<span class="kw">while</span> ( i &lt; <span class="dv">11</span> ) {
    c = a;
    a = b;
    b = b + c;
    i = i + <span class="dv">1</span>;
}</code></pre></div>
<p>Primero vamos a crear una jerarquía de tipos, detallando lo que queremos. Por una parte vamos a tener solo dos tipos de datos: números y booleanos. Pero ciertos tipos de expresiones, por ejemplo asignaciones, no tienen un tipo de retorno. Entonces otro tipo dentro de nuestra jerarquía será <code>Void</code>.</p>
<p>Empezamos con un tipo abstracto que represente la base que comparten todos los tipos de nuestro lenguaje:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Value</code></pre></div>
<p>Los booleanos simplemente serán “wrappers” de los booleanos de Scala:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">BooleanValue</span>(value: scala.<span class="fu">Boolean</span>) <span class="kw">extends</span> Value</code></pre></div>
<p>Y de forma similar con los números, a los que les agregarémos algunas funciones que nos resultarán útiles en el momento de evaluar expresiones:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">case</span> <span class="kw">class</span> <span class="fu">NumberValue</span>(value: Float) <span class="kw">extends</span> Value {

  <span class="kw">def</span> +(other: NumberValue):  NumberValue  = <span class="fu">NumberValue</span>(value + other.<span class="fu">value</span>)
  <span class="kw">def</span> *(other: NumberValue):  NumberValue  = <span class="fu">NumberValue</span>(value * other.<span class="fu">value</span>)
  <span class="kw">def</span> &lt;(other: NumberValue):  BooleanValue = <span class="fu">BooleanValue</span>(value &lt; other.<span class="fu">value</span>)
  <span class="kw">def</span> &gt;(other: NumberValue):  BooleanValue = <span class="fu">BooleanValue</span>(value &gt; other.<span class="fu">value</span>)
  <span class="kw">def</span> <span class="fu">eq</span>(other: NumberValue): BooleanValue = <span class="fu">BooleanValue</span>(value == other.<span class="fu">value</span>)

}</code></pre></div>
<p>Y por último “<code>Void</code>” que será un tipo y un valor (podríamos hacerlo solo un valor pero hacerlo de esta forma nos evita anotar algunas cosas como “<code>Void.type</code>” lo que es un poco raro):</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Void <span class="kw">extends</span> Value
<span class="kw">object</span> Void <span class="kw">extends</span> Void</code></pre></div>
<p>Algunos tal vez estén familiarizados con este patrón. Se denomina <a href="http://tech.esper.com/2014/07/30/algebraic-data-types/">Abstract Data Types</a>.</p>
<p>Pero todo lo anterior solo describe el resultado final de las computaciones. Necesitamos describir las expresiones que nuestro lenguaje soporta que al evaluarse producen alguno de los anteriores tipos.</p>
<p>La base de todo va a ser un tipo abstracto llamado <code>Expression</code> que está parametrizado según el tipo de la expresión:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> Expression[V &lt;: Value]</code></pre></div>
<p>Aquí estamos usando un <a href="http://www.scala-lang.org/old/node/136">límite de tipo</a> (el extraño <code>&lt;:</code>) para decir que el parámetro de tipo <code>V</code> debe ser un subtipo de <code>Value</code>, es decir o <code>NumberValue</code> o <code>BooleanValue</code> o <code>Void</code>.</p>
<p>Ahora veamos que tipos de expresiones tiene nuestro pequeño lenguaje:</p>
<ul>
<li>Hay <strong>literales</strong> que son valores que no se pueden evaluar más como “<code>123</code>” o “<code>True</code>”.</li>
<li>Hay <strong>asignaciones</strong> que son expresiones de tipo “<code>x = &lt;alguna expresión&gt;</code>” donde atamos el valor de una expresión al nombre de una variable.</li>
<li>Hay <strong>referencias a variables</strong> que son cuando usamos el nombre de una variable para usar su valor. Por ejemplo con nombres válidos que sean secuencias de carácteres alfabéticos como “<code>x</code>” o “<code>miVariable</code>”.</li>
<li>Hay <strong>expresiones booleanas</strong> como <strong>comparaciones</strong> (“<code>1 &lt; 2</code>” o “<code>miVariable &lt; 4</code>”) o referencias a variables booleanas.</li>
<li>Hay <strong>expresiones numéricas</strong> como <strong>operaciones binarias</strong> (“<code>1 + 3</code>” o “<code>x * 7</code>”) o referencias a variables numéricas.</li>
<li>Hay <strong>estructuras de control</strong> como <code>if() {} else {}</code> o <code>while () {}</code></li>
</ul>
</div>
    </article>
    <footer>
        <hr>
        <p>Made with <a href="http://jaspervdj.be/hakyll/">Hakyll</a>.</p>
    </footer>
    </body>
</html>
