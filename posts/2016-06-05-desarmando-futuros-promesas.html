<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <meta name="author" content="Miguel Vilá" />
        <link href="../images/favicon.ico" rel="icon">
        <meta name="viewport" content="width=device-width" />
        <meta http-equiv="Cache-Control" content="max-age=86400, must-revalidate" />

        
        <meta property="og:title" content="Desarmando las Promesas y los Futuros de la librería estándar de Scala" />
        <meta property="twitter:title" content="Desarmando las Promesas y los Futuros de la librería estándar de Scala" />
        

        
        <meta name="description" content="¿Cómo están implementadas las promesas y los futuros en la librería estándar de Scala?" />
        <meta property="og:description" content="¿Cómo están implementadas las promesas y los futuros en la librería estándar de Scala?" />
        <meta property="twitter:description" content="¿Cómo están implementadas las promesas y los futuros en la librería estándar de Scala?" />
        

        <meta property="og:type" content="website" />
        <meta property="twitter:card" content="summary" />
        <meta property="twitter:site" content="@mglvl" />

        

        <title>
            
                Desarmando las Promesas y los Futuros de la librería estándar de Scala
            
        </title>
        <link rel="stylesheet" type="text/css" href="../css/markdown.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
        <link rel="stylesheet" type="text/css" href="../css/style.css" />
        <link href="https://fonts.googleapis.com/css?family=Libre+Baskerville" rel="stylesheet" type="text/css">
        <script type="text/javascript" async src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
        </script>
    </head>
    <script type="text/javascript" src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        if(window.location.hostname !== 'localhost'){
            ga('create', 'UA-74778346-1', 'auto');
            ga('send', 'pageview');
        }
    </script>
    <body>
    <header>
        <h1>Miguel Vil&aacute;</h1>
        <nav>
            <a href="../">Inicio</a>
            <a href="../archive.html">Posts</a>
            <a href="../feed.xml"><img src="../images/feed-icon.png"></a>|
            <a href="https://twitter.com/mglvl/">Twitter</a>
            <a href="https://www.flickr.com/photos/77778296@N07/">Flickr</a>
            <a href="https://github.com/miguel-vila/">Github</a>
            <a href="https://slides.com/miguelvila/">Slides.com</a>
        </nav>
    </header>
    <article>
    <h2>Desarmando las Promesas y los Futuros de la librería estándar de Scala</h2>
    <div id="content" class="inside">
    <div class="info">
        
        Junio  5 de 2016
        
    </div>
    <div class="info">
        
        Tags: <a href="../tags/Scala.html">Scala</a>, <a href="../tags/Functional%20Programming.html">Functional Programming</a>, <a href="../tags/Monads.html">Monads</a>, <a href="../tags/Concurrency.html">Concurrency</a>, <a href="../tags/Futures.html">Futures</a>, <a href="../tags/Promises.html">Promises</a>, <a href="../tags/Async.html">Async</a> 
        
    </div>
    <hr>
    <blockquote>
<p>“What I cannot create I do not understand” - Richard Feynman</p>
</blockquote>
<h2 id="la-misma-idea-una-y-otra-vez">La misma idea, una y otra vez</h2>
<p>Hay una idea que he visto varias veces en <a href="https://twitter.com/conal/status/468875014461468677">sistemas de eventos que se pueden componer</a>. Es bastante simple y consiste en separar un flujo de eventos en dos partes:</p>
<ul>
<li>Un lado de escritura bastante <a href="https://en.wikipedia.org/wiki/Imperative_programming">imperativo</a> y dado a producir <a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">efectos secundarios</a></li>
<li>Un lado de lecturas bastante <a href="http://blog.jenkster.com/2015/12/what-is-functional-programming.html">funcional</a> desde el que se pueden combinar flujos de eventos</li>
</ul>
<p>He visto varias instancias de esta “idea”: por ejemplo <code>Observer</code> y <code>Observable</code> en <a href="http://reactivex.io/">Reactive extensions</a> o <code>Address</code> y <code>Signal</code> en <a href="http://elm-lang.org/">elm</a> (esto hasta la <a href="http://elm-lang.org/blog/farewell-to-frp">versión 0.16</a>). Uno de los ejemplos más simples son las promesas y los futuros en la librería estándar de Scala. Un Futuro es el resultado eventual de una computación y una Promesa es una variable que se puede completar con un valor exitoso o con un error. Las Promesas juegan el papel del lado de “escritura” y los Futuros el lado de “lectura”.</p>
<p>Los Futuros sirven para componer valores eventuales. Permiten hacer computaciones concurrente o paralelamente. Creo que <a href="http://danielwestheide.com/blog/2013/01/09/the-neophytes-guide-to-scala-part-8-welcome-to-the-future.html">esta</a> es una explicación muy buena de los futuros y de como se usan. <a href="https://blog.jcoglan.com/2013/03/30/callbacks-are-imperative-promises-are-functional-nodes-biggest-missed-opportunity/">Este</a> otro artículo habla de por que usar futuros es una mejor alternativa a usar <em>callbacks</em> sueltos. Este último artículo es en el contexto de node.js pero las mismas ideas aplican en otras tecnologías.</p>
<div class="note">
<p class="aside-header">
<strong>Nota aparte</strong> <span class="clickable">(Click!)</span>
</p>
<div class="note-content">
<p>Para evitar confusiones hay que aclarar que en el mundo de JavaScript llaman promesas lo que en Scala llamamos futuros.</p>
</div>
</div>
<p>Por otra parte el objetivo del presente artículo es desarmar la implementación de futuros de la librería estándar y comprender como se mueven las distintas partes. Éste artículo supone que el lector los ha usado aún sin entender como funcionan por debajo.</p>
<h2 id="desarmando-los-futuros-y-las-promesas">Desarmando los Futuros y las Promesas</h2>
<p>La implementación de Futuros y Promesas de la librería estándar tiene ciertas partes complicadas, sobre todo con respecto a la organización de las definiciones. Sin embargo creo que se puede entender la mayoría si uno tiene en cuenta la idea del lado de escritura y lectura. Con propósitos didácticos hice <a href="https://github.com/miguel-vila/grupo-concurrencia-paralelismo/tree/b0cd2b63a3daa41bcdc31c1a5b4850ba5c8007df/futuro-y-promesa">una re-escritura</a> de los Futuros y Promesas removiendo hasta dejar lo más básico y simplificando algunas partes y a esa es a la que me referiré en este artículo.</p>
<p>Entonces veamos como se podría construir nuestra propia implementación de promesas y futuros:</p>
<h2 id="las-interfaces-de-los-dos-lados">Las interfaces de los dos lados</h2>
<p>Empecemos por el Futuro, que es el lado de lectura. Inicialmente va a tener un método que permite agregar un <em>callback</em> cuando el Futuro emita algún valor, sea exitoso o fallido, para lo cuál aprovechamos el tipo <code>Try</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Futuro[T] {

  <span class="kw">def</span> <span class="fu">onComplete</span>(f: Try[T] =&gt; Unit)(<span class="kw">implicit</span> executionContext: ExecutionContext): Unit

}</code></pre></div>
<p>Recibe una función que lee el resultado y hace algo con ella e implícitamente recibe un <a href="http://www.scala-lang.org/api/2.10.3/#scala.concurrent.ExecutionContext"><code>ExecutionContext</code></a>, que es una especie de <em>pool</em> de <em>threads</em>, dónde se va a ejecutar la función eventualmente.</p>
<p>Este es el lado de lectura aunque por ahora se ve muy imperativo. Esto cambiará muy pronto gracias a la interacción con el lado de escritura.</p>
<p>La Promesa por su parte es el lugar donde se almacena el resultado de una computación eventual. Tiene una interfaz muy simple:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Promesa[T] {

  <span class="kw">def</span> futuro: Futuro[T]

  <span class="kw">def</span> <span class="fu">complete</span>(value: Try[T]): Boolean

}</code></pre></div>
<p>Tiene una propiedad de tipo <code>Futuro</code>, es decir del lado de lectura de la variable, y tiene una función <code>complete</code> que permite escribir la variable, sea con un valor exitoso o fallido. Esta última función devuelve un booleano indicando si se pudo hacer la escritura dado que nadie haya escrito la variable antes. Si se llama <code>complete</code> por segunda vez ese intento de escritura falla y retorna <code>false</code>. Se suele decir que una promesa ha sido “resuelta” cuando alguien ha escrito un valor exitoso. De forma similar se dice que ha sido “rechazada” si el valor con el que se ha escrito es erróneo.</p>
<h2 id="wishful-thinking"><em>Wishful thinking</em></h2>
<p>En este punto, con algo de <em>wishful thinking</em>, ya podemos empezar a implementar los combinadores funcionales. Imaginémos que tenemos alguna implementación de <code>Promesa</code> y <code>Futuro</code> con las interfaces de arriba y que podemos construir una promesa sin completar. Con esto ya podríamos describir <code>map</code>, uno de los combinadores funcionales más comúnes:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Futuro[T] {

  <span class="kw">def</span> <span class="fu">onComplete</span>(f: Try[T] =&gt; Unit)(<span class="kw">implicit</span> executionContext: ExecutionContext): Unit

  <span class="kw">def</span> map[S](f: T =&gt; S)(<span class="kw">implicit</span> executionContext: ExecutionContext): Futuro[S] = {
    <span class="co">// Define una promesa del tipo esperado S</span>
    <span class="kw">val</span> promesa = Promesa[S]()
    onComplete {
      <span class="kw">case</span> <span class="fu">Success</span>(t) =&gt;
        <span class="co">// &quot;Lee&quot; el valor del futuro actual y con ese valor</span>
        <span class="co">// ejecuta la función f para obtener un valor con</span>
        <span class="co">// el que escribir la promesa:</span>
        <span class="kw">val</span> value = <span class="kw">try</span> { <span class="fu">Success</span>( <span class="fu">f</span>(t) ) } <span class="kw">catch</span> { <span class="kw">case</span> <span class="fu">NonFatal</span>(error) =&gt; <span class="fu">Failure</span>(error) }
        promesa.<span class="fu">complete</span>( value )
      <span class="kw">case</span> <span class="fu">Failure</span>(error) =&gt;
        <span class="co">// Si el futuro actual es fallido escribimos la</span>
        <span class="co">// misma falla en el nuevo futuro</span>
        promesa.<span class="fu">complete</span>( <span class="fu">Failure</span>(error) )
    }
    <span class="co">// Al final devolvemos el lado de lectura de la promesa</span>
    promesa.<span class="fu">futuro</span>
  }

}</code></pre></div>
<p>Otro combinador funcional como <code>flatMap</code> se puede describir con un patrón similar pero con ciertas diferencias. Dejémoslo por aparte por ahora y veamos como se implementarían los tipos <code>Futuro</code> y <code>Promesa</code>.</p>
<h2 id="el-estado-de-una-promesa">El estado de una promesa</h2>
<p>Resulta que esto no es tan complicado. Una computación eventual puede estar en dos estados: o pendiente o completada, sea con un valor o con un error. Más aún puede que alguien haya programado la ejecución de una función que use el valor de la promesa cuando esta sea completada. Debido a esto en el estado pendiente tenemos que persistir estos pedidos. Materializando esto en tipos tenemos lo siguiente:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">sealed</span> <span class="kw">trait</span> EstadoPromesa[T]
<span class="kw">case</span> <span class="kw">class</span> Completada[T](value    : Try[T]           ) <span class="kw">extends</span> EstadoPromesa[T]
<span class="kw">case</span> <span class="kw">class</span> Pendiente [T](callbacks: List[Callback[T]]) <span class="kw">extends</span> EstadoPromesa[T]</code></pre></div>
<div class="note">
<p class="aside-header">
<strong>Nota aparte</strong> <span class="clickable">(Click!)</span>
</p>
<div class="note-content">
<p>En la implementación de verdad hay un <a href="https://github.com/scala/scala/blob/804a4cc1ff9fa159c576be7c685dbb81220c11da/src/library/scala/concurrent/impl/Promise.scala#L126">tercer posible estado</a>. Se trata de una optimización para disminuir el consumo de memoria. Éste es un detalle que no entiendo completamente pero lo demás se puede entender sin esto.</p>
</div>
</div>
<p>Aquí <code>Callback</code> es algo que lee el valor resuelto y se va a ejecutar en algún <code>ExecutionContext</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> Callback[T](callback: Try[T] =&gt; Unit, executionContext: ExecutionContext) {

  <span class="kw">def</span> <span class="fu">executeWith</span>(value: Try[T]): Unit = executionContext.<span class="fu">execute</span>(<span class="kw">new</span> Runnable {
    <span class="kw">override</span> <span class="kw">def</span> <span class="fu">run</span>(): Unit = {
      <span class="kw">try</span> {
        <span class="fu">callback</span>(value)
      } <span class="kw">catch</span> {
        <span class="kw">case</span> <span class="fu">NonFatal</span>(t) =&gt; executionContext.<span class="fu">reportFailure</span>(t)
      }
    }
  })

}</code></pre></div>
<p>En este punto les debería sonar el tipo <code>Try[T] =&gt; Unit</code>. El método <code>executeWith</code> es el que se llamará eventualmente cuando la promesa se resuelva y simplemente programa, en el <code>ExecutionContext</code>, la ejecución de la función pasándole el valor.</p>
<h2 id="una-simple-descomposición">Una simple descomposición</h2>
<p>Armados con esto lo demás sigue más o menos fácilmente. Cuándo se instancie una promesa iniciará en el estado <code>Pendiente</code>. Si, estando en este estado alguien programa la ejecución de un pedido con <code>onComplete</code> entonces debemos incluir este pedido en el estado (el atributo <code>callbacks</code>). Pero si alguien llama <code>complete</code> cuando estamos en el estado <code>Pendiente</code> pasamos a <code>Completada</code>, almacenamos ese valor y podemos ejecutar los <em>callbacks</em> que teníamos en el estado <code>Pendiente</code>. Y si alguien llama <code>onComplete</code> en el estado <code>Completada</code> podemos ejecutar ese <em>callback</em> directamente. Esencialmente tenemos esta maquina de estados:</p>
<p><img src="../images/diagrama-estado.png" style="margin-left: auto; margin-right: auto; display: block;"></p>
<h2 id="estado-y-concurrencia">Estado y concurrencia</h2>
<p>Como tal vez sospechen la cosa no es tan simple como tener una referencia mutable de tipo <code>EstadoPromesa</code>. Esto se podría prestar para multiples <a href="https://en.wikipedia.org/wiki/Race_condition">condiciones de carrera</a>. Por ejemplo ¿Qué podría pasar si se llama <code>onComplete</code> mas de una vez y al mismo tiempo sobre una promesa que no ha sido resuelta? Si la actualización del estado no se hace atómicamente podríamos correr el riesgo de que uno de los <em>callbacks</em> se pierda.</p>
<p>Debido a esto necesitamos proteger el estado contra estas condiciones de carrera. Una forma de hacerlo es con candados, pero este acercamiento tiene la gran desventaja de ser bloqueante y además es demasiado pesimista. Las situaciones en las que se le agreguen multiples <em>callbacks</em> a un mismo futuro son posibles pero no tan recurrentes, y ménos aún que se hagan al mismo tiempo. Por lo general cuando usamos un futuro le agregamos un número fijo de <em>callbacks</em> y seguimos encadenando llamadas con nuevos futuros. Pero no es común usar multiple y concurrentemente un mismo futuro. Sin embargo esta situación es posible y deberíamos protegernos contra ella. Es solo que los candados son un método demasiado “paranoico” en este caso.</p>
<p>Hay un acercamiento más optimista: suponemos que al hacer la actualización no va a haber la interferencia de otro hilo y procedemos a la modificación. Si detectamos alguna interferencia no hacemos “commit” de la actualización y reintentamos. Este es el acercamiento que tienen <a href="http://www.ibm.com/developerworks/library/j-jtp11234/">las variables atómicas</a> en Java, que aprovechan la primitiva <a href="https://en.wikipedia.org/wiki/Compare-and-swap"><em>Compare-and-swap</em></a>. Las referencias atómicas tienen un mejor <em>throughput</em> que los candados durante situaciones de moderada <a href="http://stackoverflow.com/a/7064008">contención</a>. Y en situaciones de alta contención tienen un <em>throughput</em> similar. Si quieren ahondar en este tema sugiero el capítulo 15 del libro <a href="http://jcip.net/">“Java Concurrency in Practice”</a>.</p>
<p>Dado esto, en vez de utilizar una referencia mutable de tipo <code>EstadoPromesa</code> vamos a tener algo de tipo <code>AtomicReference[ EstadoPromesa ]</code> y vamos a usar los métodos <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicReference.html#get()"><code>get</code></a> y <a href="https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/atomic/AtomicReference.html#compareAndSet(V,%20V)"><code>compareAndSet</code></a> para consultar y modificar el estado respectivamente. El método <code>compareAndSet</code> amerita una breve explicación. Recibe dos valores: el valor que se espera que va a ser el actual y el que queremos que sea el nuevo. Si el estado de la referencia atómica coincide con el que esperabamos la modificación procede y retorna <code>true</code>. En caso contrario la modificación no se hace y retorna <code>false</code>. Esto nos da la oportunidad para reintentar, y por lo que describí anteriormente el número de reintentos no debería ser muy alto, dados los patrones comunes de uso de los futuros.</p>
<div class="note">
<p class="aside-header">
<strong>Nota aparte</strong> <span class="clickable">(Click!)</span>
</p>
<div class="note-content">
<p>Cuando se usa <em>Compare-and-swap</em>, dependiendo de la estructura del problema a resolver, se puede dar una condición llamada el <a href="https://en.wikipedia.org/wiki/ABA_problem">problema ABA</a>. En los cambios de estado de las promesas no se puede dar este error, dado que los cambios se dan en una sola dirección. Es decir nunca se puede dar la situación de cambiar de vuelta a un estado anterior.</p>
</div>
</div>
<h2 id="la-estructura-de-la-implementación">La estructura de la implementación</h2>
<p>Resulta que la diferenciación entre <code>Futuro</code> y <code>Promesa</code> resulta útil para los usuarios externos de la librería. Sin embargo tanto <code>onComplete</code> como <code>complete</code> necesitan acceder al estado de la computación. Debido a esto nuestro tipo implementación puede tener la siguiente definición:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">class</span> PromesaImpl[T]
  <span class="kw">extends</span> AtomicReference[EstadoPromesa[T]](<span class="fu">Pendiente</span>(List.<span class="fu">empty</span>))
  <span class="kw">with</span> Promesa[T]
  <span class="kw">with</span> Futuro[T] {

  <span class="kw">override</span> <span class="kw">def</span> futuro: Futuro[T] = <span class="kw">this</span>

  <span class="co">// implementación de `complete` y `onComplete`</span>

}</code></pre></div>
<p>Como podrán notar heredamos de <code>AtomicReference</code> e iniciamos en el estado <code>Pendiente</code> con una lista vacía de <em>callbacks</em>.</p>
<h2 id="programando-tareas-futuras">Programando tareas futuras</h2>
<p>Primero veamos como podemos construir <code>onComplete</code>. Podemos implementar una función con esta firma:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">onComplete</span>(callback: Callback[T]): Unit</code></pre></div>
<p>y con ella podemos construir la función con la firma familiar:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">onComplete</span>(f: Try[T] =&gt; Unit)(<span class="kw">implicit</span> executionContext: ExecutionContext): Unit = {
  <span class="kw">val</span> callback = <span class="kw">new</span> Callback(f,executionContext)
  <span class="fu">onComplete</span>(callback)
}</code></pre></div>
<p>Esto se reduce a inspeccionar el estado de la promesa: si ya está resuelta pedimos inmediatamente la ejecución del <em>callback</em>. Si está <code>Pendiente</code> agregamos, atomicamente, el <em>callback</em> a la lista:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">@tailrec
<span class="kw">private</span> <span class="kw">def</span> <span class="fu">onComplete</span>(callback: Callback[T]): Unit = {
  <span class="fu">get</span>() <span class="kw">match</span> {
    <span class="kw">case</span> <span class="fu">Completada</span>(value)                          =&gt;
      callback.<span class="fu">executeWith</span>(value)
    <span class="kw">case</span> currentState @ <span class="fu">Pendiente</span>(currentCallbacks) =&gt;
      <span class="kw">if</span>(<span class="fu">compareAndSet</span>(currentState, <span class="fu">Pendiente</span>( callback :: currentCallbacks )))
        ()
      <span class="kw">else</span>
        <span class="fu">onComplete</span>(callback)
  }
}</code></pre></div>
<p>Es importante notar que:</p>
<ul>
<li><code>get</code> y <code>compareAndSet</code> son métodos heredados de <code>AtomicReference</code>.</li>
<li>Si en medio de inspeccionar el estado y modificarlo detectamos la interferencia de otro hilo, debido a que <code>compareAndSet</code> retorne <code>false</code>, reintentamos.</li>
</ul>
<h2 id="escribiendo-la-promesa">Escribiendo la promesa</h2>
<p>Para escribir la promesa, suponiendo que no ha sido resuelta anteriormente, hay que tener en cuenta que además de cambiar de <code>Pendiente</code> a <code>Completada</code> debemos recordar el listado de <em>callbacks</em>, para ejecutarlos con el valor resuelto. Para esto creamos el método <code>getCallbacksAndSetValue</code> que funciona recibiendo un valor con el que escribirá la promesa y devolverá una lista de <em>callbacks</em>. Pero también hay que tener en cuenta el caso en el que este método se llame sobre una promesa resuelta. Debido a esto nuestro tipo de retorno será <code>Option[List[Callback]]</code>:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">@tailrec
<span class="kw">private</span> <span class="kw">def</span> <span class="fu">getCallbacksAndSetValue</span>(value: Try[T]): Option[List[Callback[T]]] = {
  <span class="fu">get</span>() <span class="kw">match</span> {
    <span class="kw">case</span> <span class="fu">Completada</span>(_)                              =&gt;
      None
    <span class="kw">case</span> currentState @ <span class="fu">Pendiente</span>(currentCallbacks) =&gt;
      <span class="kw">if</span> (<span class="fu">compareAndSet</span>(currentState, <span class="fu">Completada</span>(value))) {
        Some(currentCallbacks)
      } <span class="kw">else</span> {
        <span class="fu">getCallbacksAndSetValue</span>(value)
      }
  }
}</code></pre></div>
<p>En esta función retornar <code>None</code> nos sirve para indicar que la promesa ya había sido escrita anteriormente y <code>Some</code> de una lista para indicar que la promesa fué resuelta y al mismo tiempo devolver la lista de <em>callbacks</em>. Es importante notar que, al igual que <code>onComplete</code>, esta función modifica el estado atómicamente.</p>
<p>Ahora podemos implementar <code>complete</code> de una forma muy sencilla:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">complete</span>(value: Try[T]): Boolean = {
   <span class="fu">getCallbacksAndSetValue</span>(value) <span class="kw">match</span> {
     <span class="kw">case</span> None            =&gt;
      <span class="kw">false</span>
     <span class="kw">case</span> Some(callbacks) =&gt;
      callbacks.<span class="fu">foreach</span>(_.<span class="fu">executeWith</span>(value))
      <span class="kw">true</span>
   }
 }</code></pre></div>
<p>Y ese es el corazón de como funcionan las promesas y los futuros en la librería estándar. Lo demás es solo un uso inteligente de estas bases. Por último podemos crear un constructor para las promesas:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">object</span> Promesa {

  <span class="kw">def</span> apply[T](): Promesa[T] = <span class="kw">new</span> PromesaImpl[T]()

}</code></pre></div>
<h2 id="los-constructores-más-simples">Los constructores más simples</h2>
<p><code>Futuro.successful</code> y <code>Futuro.failed</code> son constructores que sirven para envolver valores, existosos o fallidos, dentro de un Futuro. Para implementarlos debemos empezar con una versión de una promesa ya resuelta. Y para esto se deben implementar los métodos de una forma “constante” y por esto no es necesario usar un <code>ExecutionContext</code>. Para ahorrar espacio digamos que ese es un ejercicio para el lector o pueden verlo <a href="https://github.com/miguel-vila/grupo-concurrencia-paralelismo/blob/b0cd2b63a3daa41bcdc31c1a5b4850ba5c8007df/futuro-y-promesa/src/main/scala/futuro/Promesa.scala#L21-L37">acá</a>.</p>
<h2 id="los-otros-combinadores-funcionales">Los otros combinadores funcionales</h2>
<p>Ya vimos como se puede construir <code>map</code>. Sigamos con <code>flatMap</code>. La firma de <code>flatMap</code> es la siguiente:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">trait</span> Futuro[T] {

  <span class="co">//...</span>

  <span class="kw">def</span> flatMap[S](f: T =&gt; Futuro[S])(<span class="kw">implicit</span> executionContext: ExecutionContext): Futuro[S]

 <span class="co">//...</span>

}</code></pre></div>
<p>Se puede interpretar así: <code>flatMap</code> sirve para tomar un resultado eventual y encadenarlo con una computación que usa ese resultado para crear otro resultado eventual.</p>
<p>Esto es algo más complicado que <code>map</code>, pero sigue el mismo esquema de solución:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> flatMap[S](f: T =&gt; Futuro[S])(<span class="kw">implicit</span> executionContext: ExecutionContext): Futuro[S] = {
  <span class="co">// Define una promesa del tipo esperado S</span>
  <span class="kw">val</span> promesa = Promesa[S]()
  onComplete {
    <span class="kw">case</span> <span class="fu">Success</span>(t) =&gt;
      <span class="co">// &quot;Lee&quot; el valor del futuro actual y con ese valor</span>
      <span class="co">// ejecuta la función f para obtener otro futuro de</span>
      <span class="co">// tipo S</span>
      <span class="kw">try</span> {
        <span class="co">// &quot;Lee&quot; el valor de este nuevo futuro y</span>
        <span class="co">// completa la promesa con ese valor</span>
        <span class="fu">f</span>(t).<span class="fu">onComplete</span> { result2 =&gt; promesa.<span class="fu">complete</span>( result2 ) }
      } <span class="kw">catch</span> {
        <span class="co">// Maneja el error en caso de que la función f falle</span>
        <span class="kw">case</span> <span class="fu">NonFatal</span>(error) =&gt;
          promesa.<span class="fu">complete</span>( <span class="fu">Failure</span>(error) )
      }
    <span class="kw">case</span> <span class="fu">Failure</span>(error) =&gt;
      <span class="co">// Si el futuro actual es fallido resolvemos la</span>
      <span class="co">// promesa con ese error</span>
      promesa.<span class="fu">complete</span>( <span class="fu">Failure</span>(error) )
  }
  <span class="co">// Al final devolvemos el lado de lectura de la promesa</span>
  promesa.<span class="fu">futuro</span>
}</code></pre></div>
<div class="note">
<p class="aside-header">
<strong>Nota aparte</strong> <span class="clickable">(Click!)</span>
</p>
<div class="note-content">
<p>En la implementación de la librería estándar hacen varias optimizaciones, entre ellas la de enlazar promesas. Otra optimización que hacen es evitar la creación de nuevos objetos cuando el futuro es fallido, reusando el objeto de la falla y casteándolo a un futuro con el tipo esperado.</p>
</div>
</div>
<p>Pueden notar que hay una llamada a <code>onComplete</code> dentro del primer <code>onComplete</code>, lo mismo que un <em>callback</em> dentro de otro <em>callback</em>, o también una función programada a ejecutarse que eventualmente programa la ejecución de otra función.</p>
<p>También hay combinadores funcionales para manejar las fallas. Por ejemplo <code>recover</code> o <code>recoverWith</code> que mapean la falla (si es que el futuro es fallido) a algún tipo que tenga algo en común con el contenido del futuro. Pueden mirar el <a href="https://github.com/miguel-vila/grupo-concurrencia-paralelismo/tree/b14bb0a9b90a901593825f887f5e46d793a874a8/futuro-y-promesa">codigo fuente</a>, pero resulta que su implementación es muy similar a la de <code>map</code> y <code>flatMap</code> respectivamente.</p>
<p>Esta similitud es la que nos podría llevar a un refactor, que es el que precisamente hacen en <a href="https://github.com/scala/scala/blob/804a4cc1ff9fa159c576be7c685dbb81220c11da/src/library/scala/concurrent/impl/Promise.scala#L27-L44">la implementación de la librería estándar</a>. Creo que después de ver la repetición de código es más fácil entender como se puede generalizar.</p>
<h2 id="futuro.sequence-y-futuro.traverse"><code>Futuro.sequence</code> y <code>Futuro.traverse</code></h2>
<p>Otro combinador funcional común es <code>sequence</code>, que sirve para reunir múltiples resultados eventuales en uno solo. Una forma de imaginarnos como está implementado es la siguiente:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sequence[T](futuros: List[Futuro[T]])(<span class="kw">implicit</span> e: ExecutionContext): Futuro[List[T]] = {
  <span class="kw">for</span> {
    t0  &lt;- <span class="fu">futuros</span>(<span class="dv">0</span>)
    t1  &lt;- <span class="fu">futuros</span>(<span class="dv">1</span>)
    .
    .
    .
    tn  &lt;- <span class="fu">futuros</span>(n)
  } <span class="kw">yield</span> t0 :: t1 :: ... :: tn :: List.<span class="fu">empty</span>[T]
}</code></pre></div>
<p>Es decir la implementación solo depende de <code>flatMap</code> y de <code>map</code>. Más concretamente se podria materializar así:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> sequence[T](futures: List[Futuro[T]])(<span class="kw">implicit</span> e: ExecutionContext): Futuro[List[T]] = {
  futures.<span class="fu">foldRight</span>(Futuro.<span class="fu">successful</span>(List.<span class="fu">empty</span>[T])) { (fh,ftl) =&gt;
    <span class="kw">for</span> {
      h  &lt;- fh
      tl &lt;- ftl
    } <span class="kw">yield</span> h :: tl
  }
}</code></pre></div>
<p>En la librería estándar ésta función sirve no solo para listas sino también para otras estructuras de datos. Esto se logra mediante el <em>typeclass</em> <code>CanBuildFrom</code>. Si quieren saber más en la parte 3 de <a href="https://adriaanm.github.io/files/higher.pdf">este artículo</a> explican un <em>typeclass</em> similar bajo el nombre de <code>Buildable</code>.</p>
<p>La función <code>traverse</code> es muy parecida:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> traverse[A,B](list: List[A])
                 (f: A =&gt; Futuro[B])
                 (<span class="kw">implicit</span> e: ExecutionContext): Futuro[List[B]] = {
  list.<span class="fu">foldRight</span>(Futuro.<span class="fu">successful</span>(List.<span class="fu">empty</span>[B])) { (a,ftl) =&gt;
    <span class="kw">val</span> fh = <span class="fu">f</span>(a)
    <span class="kw">for</span> {
      h  &lt;- fh
      tl &lt;- ftl
    } <span class="kw">yield</span> h :: tl
  }
}</code></pre></div>
<div class="note">
<p class="aside-header">
<strong>Nota aparte</strong> <span class="clickable">(Click!)</span>
</p>
<div class="note-content">
<p>Hay algo que tal vez noten y es que las implementaciones de <code>sequence</code> y <code>traverse</code> son bastante generales. Viendo el código no hay nada específico sobre asincronía o hilos, nada que nos diga que este código debería funcionar solamente para futuros. El patrón que estámos viendo acá es el de <a href="http://strictlypositive.org/Idiom.pdf">funtores aplicativos</a> y funciona a distintos tipos de efectos.</p>
</div>
</div>
<h2 id="futuro.apply"><code>Futuro.apply</code></h2>
<p>La función <code>apply</code> del companion object <code>Futuro</code> es una de las formas más fáciles de crear futuros. Por ejemplo:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">implicit</span> <span class="kw">val</span> exec: ExecutionContext = ...
<span class="kw">val</span> myFuture = Futuro { <span class="fu">miCodigo</span>() }</code></pre></div>
<p>En este caso <code>myFuture</code> servirá como un futuro del resultado eventual de <code>miCodigo()</code>. Hacer esto sirve para hacer concurrentemente otras cosas mientras se ejecuta <code>miCodigo()</code>.</p>
<p>Una forma de implementar este método es simplemente programar la ejecución del código dentro del <code>ExecutionContext</code> y guardar el resultado en una promesa:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> apply[T](block :=&gt; T)(<span class="kw">implicit</span> executor: ExecutionContext): Futuro[T] = {
  <span class="kw">val</span> promesa = Promesa[T]()
  executor.<span class="fu">execute</span>(<span class="kw">new</span> Runnable {
    <span class="kw">override</span> <span class="kw">def</span> <span class="fu">run</span>(): Unit = {
      <span class="kw">val</span> result = Try { block }
      promesa.<span class="fu">complete</span>( result )
    }
  })
  promesa.<span class="fu">futuro</span>
}</code></pre></div>
<p>Un detalle importante de esta implementación es que el bloque de código es un argumento <em>call-by-name</em> y no <em>call-by-value</em> para que quién invoque este código no sea el que lo ejecute sino el <code>ExecutionContext</code>.</p>
<p>Pero hay otra forma de implementar esta función y es aprovechado un truco funcional:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> apply[T](block :=&gt; T)(<span class="kw">implicit</span> executor: ExecutionContext): Futuro[T] = {
  Futuro.<span class="fu">successful</span>( () ).<span class="fu">map</span>( _ =&gt; block )
}</code></pre></div>
<p>Partimos de un Futuro con un valor arbitrario y lo reemplazamos mediante map por el resultado de ejecutar el bloque. Conociendo como funcionan <code>successful</code> y <code>map</code> nos podemos dar cuenta de que ambas implementaciones hacen lo mismo.</p>
<p>Ahora ¿de qué sirve este método? ¿Sirve para convertir código bloqueante en no bloqueante? Ya sabemos como funciona por debajo para saber que la respuesta es no. Si un pedazo de código es bloqueante envolverlo con <code>Futuro { codigoBloqueante }</code> servirá para que, en un buen caso, el bloqueo suceda en otro hilo. ¿Por qué en un buen caso? Por que depende del <code>ExecutionContext</code>. Uno podría pasarle un <code>ExecutionContext</code> que ejecute lo <code>Runnable</code>s sobre el mismo <em>thread</em> que llame <code>execute</code> y con esto el <em>thread</em> que crea los futuros también se bloquearía.</p>
<h2 id="reemplazando-callbacks">Reemplazando <em>callbacks</em></h2>
<p>Hay otra forma de crear Futuros y es la que se se usa cuando se está trabajando con un API asincrónica. Incluso ya hemos visto este método de construcción. Como ejemplo supongamos que vamos a envolver un cliente HTTP asincrónico en Futuros, para así poder manipular más fácilmente los resultados.</p>
<p>Por ejemplo <a href="https://github.com/AsyncHttpClient/async-http-client">este</a> cliente en Java que se puede usar con <em>callbacks</em>:</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java">AsyncHttpClient asyncHttpClient = <span class="kw">new</span> <span class="fu">DefaultAsyncHttpClient</span>();
asyncHttpClient.<span class="fu">prepareGet</span>(<span class="st">&quot;http://www.example.com/&quot;</span>)
.<span class="fu">execute</span>(<span class="kw">new</span> AsyncCompletionHandler&lt;Response&gt;(){

    <span class="fu">@Override</span>
    <span class="kw">public</span> Response <span class="fu">onCompleted</span>(Response response) <span class="kw">throws</span> Exception{
        <span class="co">// Do something with the Response</span>
        <span class="co">// ...</span>
        <span class="kw">return</span> response;
    }

    <span class="fu">@Override</span>
    <span class="kw">public</span> <span class="dt">void</span> <span class="fu">onThrowable</span>(Throwable t){
        <span class="co">// Something wrong happened.</span>
    }
});</code></pre></div>
<p>El API permite manipular los resultados como <code>java.util.concurrent.Future</code>, pero estos tienen la desventaja de ser bloqueantes cuando se quiere manipular el resultado. Debido a esto sería deseable envolver la llamada para que retorne un <code>Futuro</code>. En Scala esto sería:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala"><span class="kw">def</span> <span class="fu">example</span>(): Futuro[Response] = {
  <span class="kw">val</span> asyncHttpClient = <span class="kw">new</span> <span class="fu">DefaultAsyncHttpClient</span>();
  <span class="kw">val</span> promesa = Promesa[Response]()
  asyncHttpClient.<span class="fu">prepareGet</span>(<span class="st">&quot;http://www.example.com/&quot;</span>)
  .<span class="fu">execute</span>(<span class="kw">new</span> AsyncCompletionHandler[Response](){

    <span class="kw">override</span> <span class="kw">def</span> <span class="fu">onCompleted</span>(Response response) = {
      promesa.<span class="fu">complete</span>( <span class="fu">Success</span>(response) )
    }
  
    <span class="kw">override</span> <span class="kw">def</span> <span class="fu">onThrowable</span>(Throwable t) = {
      promesa.<span class="fu">complete</span>( <span class="fu">Failure</span>(t) )
    }

  })
  promesa.<span class="fu">futuro</span>
}</code></pre></div>
<h2 id="uso-del-executioncontext">Uso del <code>ExecutionContext</code></h2>
<p>Conociendo la implementación podemos ahondar en un detalle. Por ejemplo, ¿hay alguna diferencia entre estos dos pedazos de código?:</p>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">futuro.<span class="fu">map</span>(f).<span class="fu">map</span>(g)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode scala"><code class="sourceCode scala">futuro.<span class="fu">map</span>(f andThen g)</code></pre></div>
<p>Resulta que no hay diferencia con respecto al valor que eventualmente computan. Incluso si <code>f</code> o <code>g</code> fallan el valor con el que se complete el Futuro será el mismo en ambos casos. La diferencia radica en el uso de recursos. La primera versión llama <code>onComplete</code> dos veces, y por lo tanto programa la ejecución de dos tareas en el <code>ExecutionContext</code>, una tras de otra. En cambio la segunda versión solo lo hace una vez. Esto quiere decir que la primera versión programa la ejecución de dos tareas muy relacionadas en hilos posiblemente distintos. En resumen cada vez que llamamos <code>map</code> o <code>flatMap</code> producimos el efecto secundario de programar una tarea en el <code>ExecutionContext</code>.</p>
<div class="note">
<p class="aside-header">
<strong>Nota aparte</strong> <span class="clickable">(Click!)</span>
</p>
<div class="note-content">
<p>Por otra parte los <a href="http://timperrett.com/2014/07/20/scalaz-task-the-missing-documentation/"><code>Task</code></a>s de <a href="http://github.com/scalaz/scalaz">scalaz</a> hacen algo diferente. Reutilizan el mismo hilo por defecto a ménos que se invoque el método <code>fork</code>. Además usan un truco de <a href="http://blog.higher-order.com/assets/trampolines.pdf">trampolines</a> para reemplazar espacio en la pila de ejecución por espacio en el <em>heap</em>.</p>
</div>
</div>
<h2 id="concluyendo">Concluyendo</h2>
<p>Hay muchas más cosas por decir sobre los futuros, sobre las decisiones de diseño y sobre qué tipo de lógica permiten separar. Pero para concluir tal vez valga la pena decir que el objetivo de desarmar los futuros es saber cómo usarlos de una mejor forma y eliminar un poco de la “magia” que uno puede atribuirles cuando se usan.</p>
<p>Cualquier comentario, sugerencia o corrección son bienvenidos.</p>
</div>

<hr>
<div class="inside">
    <div id="disqus_thread"></div>
    <script>
        var disqus_config = function () {
        this.page.url = "http://miguel-vila.github.io/posts/2016-06-05-desarmando-futuros-promesas.html";
        this.page.identifier = "posts/2016-06-05-desarmando-futuros-promesas.md".replace('posts/','').replace('.markdown',''); 
        };
        (function() { // DON'T EDIT BELOW THIS LINE
        var d = document, s = d.createElement('script');

        s.src = '//miguel-vila.disqus.com/embed.js';

        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
        })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
</div>
    </article>
    <footer>
        <hr>
        <p>Construido con <a href="http://jaspervdj.be/hakyll/">Hakyll</a>.</p>
        <div class="rc-scout"></div>
    </footer>
    <script type="text/javascript" src="../scripts/main.js"></script>
    <script async defer src="https://www.recurse-scout.com/loader.js?t=e913a8c2facd4191d76c6f34cea12f75"></script>
    </body>
</html>
